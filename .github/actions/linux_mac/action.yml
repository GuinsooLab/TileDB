name: linux-mac-steps

runs:
  using: "composite"
  steps:
    - name: 'Print env'
      run: |
        echo "'uname -s' is:"
        echo "uname: " $(uname)
        echo "uname -m: " $(uname -m)
        echo "uname -r:" $(uname -r)
        echo "uname -s: " $(uname -s)
        echo "uname -v: " $(uname -v)
        printenv
      shell: bash

    # Need this for virtualenv and arrow tests if enabled
    - uses: actions/setup-python@v2
      #if: ${{ matrix.TILEDB_ARROW_TESTS == 'ON' }}
      with:
        python-version: '3.8'

    - run: |
        set -e pipefail
        python -m pip install --upgrade pip virtualenv
        pip install pyarrow pybind11 numpy
      shell: bash

    - name: 'Build and test libtiledb'
      id: test
      shell: bash
      run: |
        # enable core dumps
        ulimit -c               # should output 0 if disabled
        ulimit -c unlimited     # Enable core dumps to be captured (must be in same run block)
        ulimit -c               # should output 'unlimited' now
        # Azure sets "SYSTEM=build" for unknown reasons, which breaks the OpenSSL configure script
        #   - openssl configure uses ENV{SYSTEM} if available:
        #     https://github.com/openssl/openssl/blob/6d745d740d37d680ff696486218b650512bbbbc6/config#L56
        #   - error description:
        #     https://developercommunity.visualstudio.com/content/problem/602584/openssl-build-error-when-using-pipelines.htm
        unset SYSTEM

        # azure bash does not treat intermediate failure as error
        # https://github.com/Microsoft/azure-pipelines-yaml/issues/135
        set -xe pipefail

        git config --global user.name 'GA CI'
        git config --global user.email 'no-reply@tiledb.io'

        if [[ "$BACKWARDS_COMPATIBILITY_ARRAYS" == "ON" ]]; then
          git clone https://github.com/TileDB-Inc/TileDB-Unit-Test-Arrays.git --branch 2.3.0 test/inputs/arrays/read_compatibility_test
        fi
        #   displayName: 'Clone Unit-Test-Arrays'

        # - bash: |
        # Start HDFS server if enabled
        if [[ "$TILEDB_HDFS" == "ON" ]]; then
          # - ssh to localhost is required for HDFS launch...
          # - /home/vsts has permissions g+w and is owned by user 'docker'
          #   for VSTS purposes, so disable ssh strictness
          sudo sed -i "s/StrictModes\ yes/StrictModes\ no/g" /etc/ssh/sshd_config

          source scripts/install-hadoop.sh
          source scripts/run-hadoop.sh
        fi

        # Start minio server if S3 is enabled
        if [[ "$TILEDB_S3" == "ON" ]]; then
          source scripts/install-minio.sh;
          source scripts/run-minio.sh;
        fi

        # Start Azurite if Azure is enabled
        if [[ "$TILEDB_AZURE" == "ON" ]]; then
          source scripts/install-azurite.sh;
          source scripts/run-azurite.sh;
        fi

        # Start GCS Emulator if GCS is enabled
        if [[ "$TILEDB_GCS" == "ON" ]]; then
          source scripts/install-gcs-emu.sh;
          source scripts/run-gcs-emu.sh;
        fi

        # Set up arguments for bootstrap.sh
        bootstrap_args="--enable=verbose";

        # Enable TILEDB_STATIC by default
        [ "$TILEDB_STATIC" ] || TILEDB_STATIC=ON
        if [[ "$TILEDB_STATIC" == "ON" ]]; then
          bootstrap_args="${bootstrap_args} --enable-static-tiledb";
        fi
        if [[ "$TILEDB_HDFS" == "ON" ]]; then
          bootstrap_args="${bootstrap_args} --enable-hdfs";
        fi;
        if [[ "$TILEDB_S3" == "ON" ]]; then
          bootstrap_args="${bootstrap_args} --enable-s3";
        fi;
        if [[ "$TILEDB_AZURE" == "ON" ]]; then
          bootstrap_args="${bootstrap_args} --enable-azure";
        fi;
        if [[ "$TILEDB_GCS" == "ON" ]]; then
          bootstrap_args="${bootstrap_args} --enable-gcs";
        fi;
        if [[ "$TILEDB_TOOLS" == "ON" ]]; then
          bootstrap_args="${bootstrap_args} --enable-tools";
        fi
        if [[ "$TILEDB_DEBUG" == "ON" ]]; then
          bootstrap_args="${bootstrap_args} --enable-debug";
        fi
        if [[ "$TILEDB_CI_ASAN" == "ON" ]]; then
          # Add address sanitizer flag if necessary
          bootstrap_args="${bootstrap_args} --enable-sanitizer=address --enable-debug";
        fi
        if [[ "$TILEDB_CI_TSAN" == "ON" ]]; then
          # Add thread sanitizer flag if necessary
          bootstrap_args="${bootstrap_args} --enable-sanitizer=thread --enable-debug";
        fi
        if [[ "$TILEDB_SERIALIZATION" == "ON" ]]; then
          # Add serialization flag if necessary
          bootstrap_args="${bootstrap_args} --enable-serialization";
        fi
        if [[ "$TILEDB_FORCE_BUILD_DEPS" == "ON" ]]; then
          # Add superbuild flag
          bootstrap_args="${bootstrap_args} --force-build-all-deps";
        fi
        if [[ "$AGENT_OS" == "Darwin" ]]; then
          # We want to be able to print a stack trace when a core dump occurs
          sudo chmod 1777 /cores
          bootstrap_args="${bootstrap_args} --enable-debug";
        fi

        # displayName: 'Install dependencies'

        mkdir -p $GITHUB_WORKSPACE/build
        cd $GITHUB_WORKSPACE/build

        # Configure and build TileDB
        echo "Bootstrapping with '$bootstrap_args'"
        $GITHUB_WORKSPACE/bootstrap $bootstrap_args

        make -j4
        make examples -j4
        make -C tiledb install

        #- bash: |
        cd $GITHUB_WORKSPACE/build
        ls -la

        if [[ ( "$AGENT_OS" == "Linux" && "$TILEDB_S3" == "ON" ) ]]; then
          # make sure docker is still running...
          printenv
          docker ps -a
        fi

        make -j4 -C tiledb tiledb_unit

        if [[ "$TILEDB_CI_ASAN" == "ON" ]]; then
          export ASAN_OPTIONS=detect_leaks=0 LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libasan.so.5
        fi

        if [[ "$AGENT_OS" == "Darwin" && "$TILEDB_GCS" == "ON" ]]; then
          # GCS unit tests are temporarily unsupported on CI for MACOS. Fake success with
          # this echo.
          echo "##vso[task.setvariable variable=TILEDB_CI_SUCCESS]1"
        else
          # run directly the executable, cmake catches the segfault and blocks
          # the core dump
          ./tiledb/test/tiledb_unit -d yes
        fi

        # Kill the running Minio server, OSX only because Linux runs it within
        # docker.
        if [[ ( "$AGENT_OS" == "Darwin" && "$TILEDB_S3" == "ON" ) ]]; then
          kill -9 $MINIO_PID
        fi

        # Kill the running Azurite server
        if [[ "$TILEDB_AZURE" == "ON" ]]; then
          kill -9 $AZURITE_PID
        fi

        # Kill the running GCS emulator server Linux only because OSX does not
        # run the emulator
        if [[ "$AGENT_OS" != "Darwin" && "$TILEDB_GCS" == "ON" ]]; then
          kill -9 $GCS_PID
        fi

    - name: 'macOS core dump stacks'
      if: ${{ failure() == true && startsWith(runner.name, 'macos-') == true }} # only run this job if the build step failed
      shell: bash
      run: |
        nfiles=$(ls /cores | wc -l)
        if [[ $nfiles -eq 0 ]]; then
          echo "no core files found"
          exit 0
        fi
        ls -la /cores
        for f in $(find /cores -name 'core.*');
          do
            echo "stack trace for $f"
            lldb -c $f --batch -o 'bt all' -o 'quit'
          done;

    - name: 'macOS upload core artifacts' # https://github.com/actions/upload-artifact#where-does-the-upload-go
      if: ${{ failure() == true && startsWith(runner.name, 'macos-') == true }} # only run this job if the build step failed
      uses: actions/upload-artifact@v2
      with:
        retention-days: 10
        name: "${{ runner.name }}.coredumps.${{ github.job }}.${{ github.run_number }}.${{github.run_id}}.${{github.run_attempt}}"
        if-no-files-found: warn # 'ignore/', 'warn' or 'error' are available, defaults to `warn`
        path: |
          /cores/

    - name: 'ubuntu dump core stacks'
      if: ${{ failure() && startsWith(runner.name, 'ubuntu-') == true }} # only run this job if the build step failed
      shell: bash
      run: |
        # following contains answers with various possibilities for locating core files on various systems
        # https://stackoverflow.com/questions/2065912/core-dumped-but-core-file-is-not-in-the-current-directory
        pwd
        if [[ ! $(find /var/lib/apport/coredump -name 'core.*') ]]; then
          # if we don't find the core files where/as expected, then
          # the artifacts won't get uploaded (haven't figured out how to
          # dynamically specify location to upload action), but we
          # can still present stack traces for the ones we find.
          echo "core files not found where expected!"
          if [[ $(find . -name 'core.*') ]]; then
            echo "core files found at/under $(pwd)"
            corefiles=$(find . -name 'core.*')
          elif [[ $(find / -name 'core.*') ]]; then
            echo "core founds found!"
            corefiles=$(find / -name 'core.*')
          else
            echo "core files expected but not found!"
            corefiles=
          fi
        else
          corefiles=$(find /var/lib/apport/coredump -name 'core.*')
        fi
        ulimit -c
        echo "ls -l /var/lib/apport/coredump"
        ls -l /var/lib/apport/coredump
        for f in $corefiles;
          do
            echo "stack trace for $f"
            if [[ -f $(which gdb) ]]; then
              dbgr=$(which gdb)
              sudo $dbgr -q --core $f -ex "thread apply all bt" -ex "quit"
            #fi
            # lldb ref'd here located by doing trial in runner with find / -name "*lldb*" and sifting through the results.
            elif [[ -f /usr/lib/llvm-11/bin/lldb ]]; then
              dbgr="/usr/lib/llvm-11/bin/lldb"
              sudo $dbgr -core $f --batch  -o 'bt all' -o 'quit'
            else
              echo "debugger not found in previously seen location!"
              exit 1
            fi
          done;

    - name: 'ubuntu upload any core artifacts' # https://github.com/actions/upload-artifact#where-does-the-upload-go
      if: ${{ always() == true && startsWith(runner.name, 'ubuntu-') == true }} # only run this job if the build step failed
      uses: actions/upload-artifact@v2
      with:
        retention-days: 10
        name: "coredumps.${{ github.job }}.${{ runner.name }}.${{ github.run_number }}.${{github.run_id}}.${{github.run_attempt}}"
        if-no-files-found: warn # 'ignore', 'warn' or 'error' are available, defaults to `warn`
        path: |
          /var/lib/apport/coredump/

    - name: 'Test status check'
      shell: bash
      run: |
        # tiledb_unit is configured to set a job-level variable TILEDB_CI_SUCCESS=1
        # following the test run. If this variable is not set, the build should fail.
        # see https://github.com/TileDB-Inc/TileDB/pull/1400 (5f0623f4d3)
        if [[ "${{ steps.test.outputs.TILEDB_CI_SUCCESS }}" -ne 1 ]]; then
          exit 1;
        fi

    - name: "Print log files (failed build only)"
      if: ${{ failure() }} # only run this job if the build step failed
      shell: bash
      run: |
        source $GITHUB_WORKSPACE/scripts/ci/print_logs.sh
